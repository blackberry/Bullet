static const char* solverKernelsCL= \
"#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_extended_atomics : enable\n"
"\n"
"\n"
"#ifdef cl_ext_atomic_counters_32\n"
"#pragma OPENCL EXTENSION cl_ext_atomic_counters_32 : enable\n"
"#else\n"
"#define counter32_t volatile global int*\n"
"#endif\n"
"\n"
"typedef unsigned int u32;\n"
"typedef unsigned short u16;\n"
"typedef unsigned char u8;\n"
"\n"
"#define GET_GROUP_IDX get_group_id(0)\n"
"#define GET_LOCAL_IDX get_local_id(0)\n"
"#define GET_GLOBAL_IDX get_global_id(0)\n"
"#define GET_GROUP_SIZE get_local_size(0)\n"
"#define GET_NUM_GROUPS get_num_groups(0)\n"
"#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\n"
"#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\n"
"#define AtomInc(x) atom_inc(&(x))\n"
"#define AtomInc1(x, out) out = atom_inc(&(x))\n"
"#define AppendInc(x, out) out = atomic_inc(x)\n"
"#define AtomAdd(x, value) atom_add(&(x), value)\n"
"#define AtomCmpxhg(x, cmp, value) atom_cmpxchg( &(x), cmp, value )\n"
"#define AtomXhg(x, value) atom_xchg ( &(x), value )\n"
"\n"
"\n"
"#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\n"
"\n"
"#define make_float4 (float4)\n"
"#define make_float2 (float2)\n"
"#define make_uint4 (uint4)\n"
"#define make_int4 (int4)\n"
"#define make_uint2 (uint2)\n"
"#define make_int2 (int2)\n"
"\n"
"\n"
"#define max2 max\n"
"#define min2 min\n"
"\n"
"\n"
"///////////////////////////////////////\n"
"//	Vector\n"
"///////////////////////////////////////\n"
"__inline\n"
"float fastDiv(float numerator, float denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"//	return numerator/denominator;	\n"
"}\n"
"\n"
"__inline\n"
"float4 fastDiv4(float4 numerator, float4 denominator)\n"
"{\n"
"	return native_divide(numerator, denominator);	\n"
"}\n"
"\n"
"__inline\n"
"float fastSqrtf(float f2)\n"
"{\n"
"	return native_sqrt(f2);\n"
"//	return sqrt(f2);\n"
"}\n"
"\n"
"__inline\n"
"float fastRSqrt(float f2)\n"
"{\n"
"	return native_rsqrt(f2);\n"
"}\n"
"\n"
"__inline\n"
"float fastLength4(float4 v)\n"
"{\n"
"	return fast_length(v);\n"
"}\n"
"\n"
"__inline\n"
"float4 fastNormalize4(float4 v)\n"
"{\n"
"	return fast_normalize(v);\n"
"}\n"
"\n"
"\n"
"__inline\n"
"float sqrtf(float a)\n"
"{\n"
"//	return sqrt(a);\n"
"	return native_sqrt(a);\n"
"}\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = make_float4(a.xyz,0.f);\n"
"	float4 b1 = make_float4(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"float length3(const float4 a)\n"
"{\n"
"	return sqrtf(dot3F4(a,a));\n"
"}\n"
"\n"
"__inline\n"
"float dot4(const float4 a, const float4 b)\n"
"{\n"
"	return dot( a, b );\n"
"}\n"
"\n"
"//	for height\n"
"__inline\n"
"float dot3w1(const float4 point, const float4 eqn)\n"
"{\n"
"	return dot3F4(point,eqn) + eqn.w;\n"
"}\n"
"\n"
"__inline\n"
"float4 normalize3(const float4 a)\n"
"{\n"
"	float4 n = make_float4(a.x, a.y, a.z, 0.f);\n"
"	return fastNormalize4( n );\n"
"//	float length = sqrtf(dot3F4(a, a));\n"
"//	return 1.f/length * a;\n"
"}\n"
"\n"
"__inline\n"
"float4 normalize4(const float4 a)\n"
"{\n"
"	float length = sqrtf(dot4(a, a));\n"
"	return 1.f/length * a;\n"
"}\n"
"\n"
"__inline\n"
"float4 createEquation(const float4 a, const float4 b, const float4 c)\n"
"{\n"
"	float4 eqn;\n"
"	float4 ab = b-a;\n"
"	float4 ac = c-a;\n"
"	eqn = normalize3( cross3(ab, ac) );\n"
"	eqn.w = -dot3F4(eqn,a);\n"
"	return eqn;\n"
"}\n"
"\n"
"///////////////////////////////////////\n"
"//	Matrix3x3\n"
"///////////////////////////////////////\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_row[3];\n"
"}Matrix3x3;\n"
"\n"
"__inline\n"
"Matrix3x3 mtZero();\n"
"\n"
"__inline\n"
"Matrix3x3 mtIdentity();\n"
"\n"
"__inline\n"
"Matrix3x3 mtTranspose(Matrix3x3 m);\n"
"\n"
"__inline\n"
"Matrix3x3 mtMul(Matrix3x3 a, Matrix3x3 b);\n"
"\n"
"__inline\n"
"float4 mtMul1(Matrix3x3 a, float4 b);\n"
"\n"
"__inline\n"
"float4 mtMul3(float4 a, Matrix3x3 b);\n"
"\n"
"__inline\n"
"Matrix3x3 mtZero()\n"
"{\n"
"	Matrix3x3 m;\n"
"	m.m_row[0] = (float4)(0.f);\n"
"	m.m_row[1] = (float4)(0.f);\n"
"	m.m_row[2] = (float4)(0.f);\n"
"	return m;\n"
"}\n"
"\n"
"__inline\n"
"Matrix3x3 mtIdentity()\n"
"{\n"
"	Matrix3x3 m;\n"
"	m.m_row[0] = (float4)(1,0,0,0);\n"
"	m.m_row[1] = (float4)(0,1,0,0);\n"
"	m.m_row[2] = (float4)(0,0,1,0);\n"
"	return m;\n"
"}\n"
"\n"
"__inline\n"
"Matrix3x3 mtTranspose(Matrix3x3 m)\n"
"{\n"
"	Matrix3x3 out;\n"
"	out.m_row[0] = (float4)(m.m_row[0].x, m.m_row[1].x, m.m_row[2].x, 0.f);\n"
"	out.m_row[1] = (float4)(m.m_row[0].y, m.m_row[1].y, m.m_row[2].y, 0.f);\n"
"	out.m_row[2] = (float4)(m.m_row[0].z, m.m_row[1].z, m.m_row[2].z, 0.f);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Matrix3x3 mtMul(Matrix3x3 a, Matrix3x3 b)\n"
"{\n"
"	Matrix3x3 transB;\n"
"	transB = mtTranspose( b );\n"
"	Matrix3x3 ans;\n"
"	//	why this doesn't run when 0ing in the for{}\n"
"	a.m_row[0].w = 0.f;\n"
"	a.m_row[1].w = 0.f;\n"
"	a.m_row[2].w = 0.f;\n"
"	for(int i=0; i<3; i++)\n"
"	{\n"
"//	a.m_row[i].w = 0.f;\n"
"		ans.m_row[i].x = dot3F4(a.m_row[i],transB.m_row[0]);\n"
"		ans.m_row[i].y = dot3F4(a.m_row[i],transB.m_row[1]);\n"
"		ans.m_row[i].z = dot3F4(a.m_row[i],transB.m_row[2]);\n"
"		ans.m_row[i].w = 0.f;\n"
"	}\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 mtMul1(Matrix3x3 a, float4 b)\n"
"{\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a.m_row[0], b );\n"
"	ans.y = dot3F4( a.m_row[1], b );\n"
"	ans.z = dot3F4( a.m_row[2], b );\n"
"	ans.w = 0.f;\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 mtMul3(float4 a, Matrix3x3 b)\n"
"{\n"
"	float4 colx = make_float4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\n"
"	float4 coly = make_float4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\n"
"	float4 colz = make_float4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\n"
"\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a, colx );\n"
"	ans.y = dot3F4( a, coly );\n"
"	ans.z = dot3F4( a, colz );\n"
"	return ans;\n"
"}\n"
"\n"
"///////////////////////////////////////\n"
"//	Quaternion\n"
"///////////////////////////////////////\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"__inline\n"
"Matrix3x3 qtGetRotationMatrix(Quaternion q);\n"
"\n"
"\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtNormalize(Quaternion in)\n"
"{\n"
"	return fastNormalize4(in);\n"
"//	in /= length( in );\n"
"//	return in;\n"
"}\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"Matrix3x3 qtGetRotationMatrix(Quaternion quat)\n"
"{\n"
"	float4 quat2 = (float4)(quat.x*quat.x, quat.y*quat.y, quat.z*quat.z, 0.f);\n"
"	Matrix3x3 out;\n"
"\n"
"	out.m_row[0].x=1-2*quat2.y-2*quat2.z;\n"
"	out.m_row[0].y=2*quat.x*quat.y-2*quat.w*quat.z;\n"
"	out.m_row[0].z=2*quat.x*quat.z+2*quat.w*quat.y;\n"
"	out.m_row[0].w = 0.f;\n"
"\n"
"	out.m_row[1].x=2*quat.x*quat.y+2*quat.w*quat.z;\n"
"	out.m_row[1].y=1-2*quat2.x-2*quat2.z;\n"
"	out.m_row[1].z=2*quat.y*quat.z-2*quat.w*quat.x;\n"
"	out.m_row[1].w = 0.f;\n"
"\n"
"	out.m_row[2].x=2*quat.x*quat.z-2*quat.w*quat.y;\n"
"	out.m_row[2].y=2*quat.y*quat.z+2*quat.w*quat.x;\n"
"	out.m_row[2].z=1-2*quat2.x-2*quat2.y;\n"
"	out.m_row[2].w = 0.f;\n"
"\n"
"	return out;\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"#define WG_SIZE 64\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	Quaternion m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_shapeIdx;\n"
"	u32 m_shapeType;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} Body;\n"
"\n"
"typedef struct\n"
"{\n"
"	Matrix3x3 m_invInertia;\n"
"	Matrix3x3 m_initInvInertia;\n"
"} Shape;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_linear;\n"
"	float4 m_worldPos[4];\n"
"	float4 m_center;	\n"
"	float m_jacCoeffInv[4];\n"
"	float m_b[4];\n"
"	float m_appliedRambdaDt[4];\n"
"\n"
"	float m_fJacCoeffInv[2];	\n"
"	float m_fAppliedRambdaDt[2];	\n"
"\n"
"	u32 m_bodyA;\n"
"	u32 m_bodyB;\n"
"\n"
"	int m_batchIdx;\n"
"	u32 m_paddings[1];\n"
"} Constraint4;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_worldPos[4];\n"
"	float4 m_worldNormal;\n"
"	u32 m_coeffs;\n"
"	int m_batchIdx;\n"
"\n"
"	u32 m_bodyAPtr;\n"
"	u32 m_bodyBPtr;\n"
"} Contact4;\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_nConstraints;\n"
"	int m_start;\n"
"	int m_batchIdx;\n"
"	int m_nSplit;\n"
"//	int m_paddings[1];\n"
"} ConstBuffer;\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_solveFriction;\n"
"	int m_maxBatch;	//	long batch really kills the performance\n"
"	int m_batchIdx;\n"
"	int m_nSplit;\n"
"//	int m_paddings[1];\n"
"} ConstBufferBatchSolve;\n"
"\n"
"\n"
"void setLinearAndAngular( float4 n, float4 r0, float4 r1, float4* linear, float4* angular0, float4* angular1)\n"
"{\n"
"	*linear = -n;\n"
"	*angular0 = -cross3(r0, n);\n"
"	*angular1 = cross3(r1, n);\n"
"}\n"
"\n"
"\n"
"float calcRelVel( float4 l0, float4 l1, float4 a0, float4 a1, float4 linVel0, float4 angVel0, float4 linVel1, float4 angVel1 )\n"
"{\n"
"	return dot3F4(l0, linVel0) + dot3F4(a0, angVel0) + dot3F4(l1, linVel1) + dot3F4(a1, angVel1);\n"
"}\n"
"\n"
"\n"
"float calcJacCoeff(const float4 linear0, const float4 linear1, const float4 angular0, const float4 angular1,\n"
"					float invMass0, const Matrix3x3* invInertia0, float invMass1, const Matrix3x3* invInertia1)\n"
"{\n"
"	//	linear0,1 are normlized\n"
"	float jmj0 = invMass0;//dot3F4(linear0, linear0)*invMass0;\n"
"	float jmj1 = dot3F4(mtMul3(angular0,*invInertia0), angular0);\n"
"	float jmj2 = invMass1;//dot3F4(linear1, linear1)*invMass1;\n"
"	float jmj3 = dot3F4(mtMul3(angular1,*invInertia1), angular1);\n"
"	return -1.f/(jmj0+jmj1+jmj2+jmj3);\n"
"}\n"
"\n"
"\n"
"\n"
"void solveContact(__global Constraint4* cs,\n"
"			float4 posA, float4* linVelA, float4* angVelA, float invMassA, Matrix3x3 invInertiaA,\n"
"			float4 posB, float4* linVelB, float4* angVelB, float invMassB, Matrix3x3 invInertiaB)\n"
"{\n"
"	float minRambdaDt = 0;\n"
"	float maxRambdaDt = FLT_MAX;\n"
"\n"
"	for(int ic=0; ic<4; ic++)\n"
"	{\n"
"		if( cs->m_jacCoeffInv[ic] == 0.f ) continue;\n"
"\n"
"		float4 angular0, angular1, linear;\n"
"		float4 r0 = cs->m_worldPos[ic] - posA;\n"
"		float4 r1 = cs->m_worldPos[ic] - posB;\n"
"		setLinearAndAngular( -cs->m_linear, r0, r1, &linear, &angular0, &angular1 );\n"
"\n"
"		float rambdaDt = calcRelVel( cs->m_linear, -cs->m_linear, angular0, angular1, \n"
"			*linVelA, *angVelA, *linVelB, *angVelB ) + cs->m_b[ic];\n"
"		rambdaDt *= cs->m_jacCoeffInv[ic];\n"
"\n"
"		{\n"
"			float prevSum = cs->m_appliedRambdaDt[ic];\n"
"			float updated = prevSum;\n"
"			updated += rambdaDt;\n"
"			updated = max2( updated, minRambdaDt );\n"
"			updated = min2( updated, maxRambdaDt );\n"
"			rambdaDt = updated - prevSum;\n"
"			cs->m_appliedRambdaDt[ic] = updated;\n"
"		}\n"
"\n"
"		float4 linImp0 = invMassA*linear*rambdaDt;\n"
"		float4 linImp1 = invMassB*(-linear)*rambdaDt;\n"
"		float4 angImp0 = mtMul1(invInertiaA, angular0)*rambdaDt;\n"
"		float4 angImp1 = mtMul1(invInertiaB, angular1)*rambdaDt;\n"
"\n"
"		*linVelA += linImp0;\n"
"		*angVelA += angImp0;\n"
"		*linVelB += linImp1;\n"
"		*angVelB += angImp1;\n"
"	}\n"
"}\n"
"\n"
"\n"
"void solveFriction(__global Constraint4* cs,\n"
"			float4 posA, float4* linVelA, float4* angVelA, float invMassA, Matrix3x3 invInertiaA,\n"
"			float4 posB, float4* linVelB, float4* angVelB, float invMassB, Matrix3x3 invInertiaB,\n"
"			float maxRambdaDt[4], float minRambdaDt[4])\n"
"{\n"
"	if( cs->m_fJacCoeffInv[0] == 0 && cs->m_fJacCoeffInv[0] == 0 ) return;\n"
"	const float4 center = cs->m_center;\n"
"\n"
"	float4 n = -cs->m_linear;\n"
"\n"
"	float4 tangent[2];\n"
"	tangent[0] = cross3( n, cs->m_worldPos[0]-center );\n"
"	tangent[1] = cross3( tangent[0], n );\n"
"	tangent[0] = normalize3( tangent[0] );\n"
"	tangent[1] = normalize3( tangent[1] );\n"
"\n"
"	float4 angular0, angular1, linear;\n"
"	float4 r0 = center - posA;\n"
"	float4 r1 = center - posB;\n"
"	for(int i=0; i<2; i++)\n"
"	{\n"
"		setLinearAndAngular( tangent[i], r0, r1, &linear, &angular0, &angular1 );\n"
"		float rambdaDt = calcRelVel(linear, -linear, angular0, angular1,\n"
"			*linVelA, *angVelA, *linVelB, *angVelB );\n"
"		rambdaDt *= cs->m_fJacCoeffInv[i];\n"
"\n"
"		{\n"
"			float prevSum = cs->m_fAppliedRambdaDt[i];\n"
"			float updated = prevSum;\n"
"			updated += rambdaDt;\n"
"			updated = max2( updated, minRambdaDt[i] );\n"
"			updated = min2( updated, maxRambdaDt[i] );\n"
"			rambdaDt = updated - prevSum;\n"
"			cs->m_fAppliedRambdaDt[i] = updated;\n"
"		}\n"
"\n"
"		float4 linImp0 = invMassA*linear*rambdaDt;\n"
"		float4 linImp1 = invMassB*(-linear)*rambdaDt;\n"
"		float4 angImp0 = mtMul1(invInertiaA, angular0)*rambdaDt;\n"
"		float4 angImp1 = mtMul1(invInertiaB, angular1)*rambdaDt;\n"
"\n"
"		*linVelA += linImp0;\n"
"		*angVelA += angImp0;\n"
"		*linVelB += linImp1;\n"
"		*angVelB += angImp1;\n"
"	}\n"
"	{	//	angular damping for point constraint\n"
"		float4 ab = normalize3( posB - posA );\n"
"		float4 ac = normalize3( center - posA );\n"
"		if( dot3F4( ab, ac ) > 0.95f  || (invMassA == 0.f || invMassB == 0.f))\n"
"		{\n"
"			float angNA = dot3F4( n, *angVelA );\n"
"			float angNB = dot3F4( n, *angVelB );\n"
"\n"
"			*angVelA -= (angNA*0.1f)*n;\n"
"			*angVelB -= (angNB*0.1f)*n;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"void solveAConstraint(__global Body* gBodies, __global Shape* gShapes, __global Constraint4* ldsCs)\n"
"{\n"
"	float frictionCoeff = ldsCs[0].m_linear.w;\n"
"	int aIdx = ldsCs[0].m_bodyA;\n"
"	int bIdx = ldsCs[0].m_bodyB;\n"
"\n"
"	float4 posA = gBodies[aIdx].m_pos;\n"
"	float4 linVelA = gBodies[aIdx].m_linVel;\n"
"	float4 angVelA = gBodies[aIdx].m_angVel;\n"
"	float invMassA = gBodies[aIdx].m_invMass;\n"
"	Matrix3x3 invInertiaA = gShapes[aIdx].m_invInertia;\n"
"\n"
"	float4 posB = gBodies[bIdx].m_pos;\n"
"	float4 linVelB = gBodies[bIdx].m_linVel;\n"
"	float4 angVelB = gBodies[bIdx].m_angVel;\n"
"	float invMassB = gBodies[bIdx].m_invMass;\n"
"	Matrix3x3 invInertiaB = gShapes[bIdx].m_invInertia;\n"
"		\n"
"		\n"
"	{\n"
"		solveContact( ldsCs, posA, &linVelA, &angVelA, invMassA, invInertiaA,\n"
"			posB, &linVelB, &angVelB, invMassB, invInertiaB );\n"
"	}\n"
"\n"
"	{\n"
"		float maxRambdaDt[4] = {FLT_MAX,FLT_MAX,FLT_MAX,FLT_MAX};\n"
"		float minRambdaDt[4] = {0.f,0.f,0.f,0.f};\n"
"\n"
"		float sum = 0;\n"
"		for(int j=0; j<4; j++)\n"
"		{\n"
"			sum +=ldsCs[0].m_appliedRambdaDt[j];\n"
"		}\n"
"		frictionCoeff = 0.7f;\n"
"		for(int j=0; j<4; j++)\n"
"		{\n"
"			maxRambdaDt[j] = frictionCoeff*sum;\n"
"			minRambdaDt[j] = -maxRambdaDt[j];\n"
"		}\n"
"\n"
"		solveFriction( ldsCs, posA, &linVelA, &angVelA, invMassA, invInertiaA,\n"
"			posB, &linVelB, &angVelB, invMassB, invInertiaB, maxRambdaDt, minRambdaDt );\n"
"	}\n"
"\n"
"	gBodies[aIdx].m_linVel = linVelA;\n"
"	gBodies[aIdx].m_angVel = angVelA;\n"
"	gBodies[bIdx].m_linVel = linVelB;\n"
"	gBodies[bIdx].m_angVel = angVelB;\n"
"}\n"
"\n"
"void solveContactConstraint(__global Body* gBodies, __global Shape* gShapes, __global Constraint4* ldsCs)\n"
"{\n"
"	float frictionCoeff = ldsCs[0].m_linear.w;\n"
"	int aIdx = ldsCs[0].m_bodyA;\n"
"	int bIdx = ldsCs[0].m_bodyB;\n"
"\n"
"	float4 posA = gBodies[aIdx].m_pos;\n"
"	float4 linVelA = gBodies[aIdx].m_linVel;\n"
"	float4 angVelA = gBodies[aIdx].m_angVel;\n"
"	float invMassA = gBodies[aIdx].m_invMass;\n"
"	Matrix3x3 invInertiaA = gShapes[aIdx].m_invInertia;\n"
"\n"
"	float4 posB = gBodies[bIdx].m_pos;\n"
"	float4 linVelB = gBodies[bIdx].m_linVel;\n"
"	float4 angVelB = gBodies[bIdx].m_angVel;\n"
"	float invMassB = gBodies[bIdx].m_invMass;\n"
"	Matrix3x3 invInertiaB = gShapes[bIdx].m_invInertia;\n"
"\n"
"	solveContact( ldsCs, posA, &linVelA, &angVelA, invMassA, invInertiaA,\n"
"			posB, &linVelB, &angVelB, invMassB, invInertiaB );\n"
"\n"
"	gBodies[aIdx].m_linVel = linVelA;\n"
"	gBodies[aIdx].m_angVel = angVelA;\n"
"	gBodies[bIdx].m_linVel = linVelB;\n"
"	gBodies[bIdx].m_angVel = angVelB;\n"
"}\n"
"\n"
"void solveFrictionConstraint(__global Body* gBodies, __global Shape* gShapes, __global Constraint4* ldsCs)\n"
"{\n"
"	float frictionCoeff = ldsCs[0].m_linear.w;\n"
"	int aIdx = ldsCs[0].m_bodyA;\n"
"	int bIdx = ldsCs[0].m_bodyB;\n"
"\n"
"	float4 posA = gBodies[aIdx].m_pos;\n"
"	float4 linVelA = gBodies[aIdx].m_linVel;\n"
"	float4 angVelA = gBodies[aIdx].m_angVel;\n"
"	float invMassA = gBodies[aIdx].m_invMass;\n"
"	Matrix3x3 invInertiaA = gShapes[aIdx].m_invInertia;\n"
"\n"
"	float4 posB = gBodies[bIdx].m_pos;\n"
"	float4 linVelB = gBodies[bIdx].m_linVel;\n"
"	float4 angVelB = gBodies[bIdx].m_angVel;\n"
"	float invMassB = gBodies[bIdx].m_invMass;\n"
"	Matrix3x3 invInertiaB = gShapes[bIdx].m_invInertia;\n"
"\n"
"	{\n"
"		float maxRambdaDt[4] = {FLT_MAX,FLT_MAX,FLT_MAX,FLT_MAX};\n"
"		float minRambdaDt[4] = {0.f,0.f,0.f,0.f};\n"
"\n"
"		float sum = 0;\n"
"		for(int j=0; j<4; j++)\n"
"		{\n"
"			sum +=ldsCs[0].m_appliedRambdaDt[j];\n"
"		}\n"
"		frictionCoeff = 0.7f;\n"
"		for(int j=0; j<4; j++)\n"
"		{\n"
"			maxRambdaDt[j] = frictionCoeff*sum;\n"
"			minRambdaDt[j] = -maxRambdaDt[j];\n"
"		}\n"
"\n"
"		solveFriction( ldsCs, posA, &linVelA, &angVelA, invMassA, invInertiaA,\n"
"			posB, &linVelB, &angVelB, invMassB, invInertiaB, maxRambdaDt, minRambdaDt );\n"
"	}\n"
"\n"
"	gBodies[aIdx].m_linVel = linVelA;\n"
"	gBodies[aIdx].m_angVel = angVelA;\n"
"	gBodies[bIdx].m_linVel = linVelB;\n"
"	gBodies[bIdx].m_angVel = angVelB;\n"
"}\n"
"\n"
"typedef struct \n"
"{\n"
"	int m_valInt0;\n"
"	int m_valInt1;\n"
"	int m_valInt2;\n"
"	int m_valInt3;\n"
"\n"
"	float m_val0;\n"
"	float m_val1;\n"
"	float m_val2;\n"
"	float m_val3;\n"
"} SolverDebugInfo;\n"
"\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"//void BatchSolveKernel(__global Body* gBodies, __global Shape* gShapes, __global Constraint4* gConstraints, 	__global int* gN, __global int* gOffsets, __global SolverDebugInfo* debugInfo, ConstBufferBatchSolve cb)\n"
"void BatchSolveKernel(__global Body* gBodies, \n"
"__global Shape* gShapes, \n"
"__global Constraint4* gConstraints, 	\n"
"__global int* gN, \n"
"__global int* gOffsets, \n"
"ConstBufferBatchSolve cb)\n"
"{\n"
"	__local int ldsBatchIdx[WG_SIZE+1];\n"
"\n"
"	__local int ldsCurBatch;\n"
"	__local int ldsNextBatch;\n"
"	__local int ldsStart;\n"
"\n"
"	int lIdx = GET_LOCAL_IDX;\n"
"	int wgIdx = GET_GROUP_IDX;\n"
"\n"
"	int gIdx = GET_GLOBAL_IDX;\n"
"//	debugInfo[gIdx].m_valInt0 = gIdx;\n"
"	//debugInfo[gIdx].m_valInt1 = GET_GROUP_SIZE;\n"
"\n"
"	const int solveFriction = cb.m_solveFriction;\n"
"	const int maxBatch = cb.m_maxBatch;\n"
"	const int bIdx = cb.m_batchIdx;\n"
"	const int nSplit = cb.m_nSplit;\n"
"\n"
"	int xIdx = (wgIdx/(nSplit/2))*2 + (bIdx&1);\n"
"	int yIdx = (wgIdx%(nSplit/2))*2 + (bIdx>>1);\n"
"	int cellIdx = xIdx+yIdx*nSplit;\n"
"	\n"
"	if( gN[cellIdx] == 0 ) \n"
"		return;\n"
"\n"
"	const int start = gOffsets[cellIdx];\n"
"	const int end = start + gN[cellIdx];\n"
"\n"
"	\n"
"	if( lIdx == 0 )\n"
"	{\n"
"		ldsCurBatch = 0;\n"
"		ldsNextBatch = 0;\n"
"		ldsStart = start;\n"
"	}\n"
"\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	int idx=ldsStart+lIdx;\n"
"	while (ldsCurBatch < maxBatch)\n"
"	{\n"
"		for(; idx<end; )\n"
"		{\n"
"			if (gConstraints[idx].m_batchIdx == ldsCurBatch)\n"
"			{\n"
"				if( solveFriction )\n"
"					solveFrictionConstraint( gBodies, gShapes, &gConstraints[idx] );\n"
"				else\n"
"					solveContactConstraint( gBodies, gShapes, &gConstraints[idx] );\n"
"				idx+=64;\n"
"			} else\n"
"			{\n"
"				break;\n"
"			}\n"
"		}\n"
"		GROUP_LDS_BARRIER;\n"
"		if( lIdx == 0 )\n"
"		{\n"
"			ldsCurBatch++;\n"
"		}\n"
"		GROUP_LDS_BARRIER;\n"
"	}\n"
"	\n"
"	return;\n"
"\n"
"\n"
"	int counter0 = 0;\n"
"	int counter1 = 0;\n"
"\n"
"	do\n"
"	{\n"
"		counter0++;\n"
"		int curStart = ldsStart;\n"
"		int curBatch = ldsCurBatch;\n"
"\n"
"		GROUP_LDS_BARRIER;\n"
"\n"
"		while( curBatch == ldsNextBatch && curStart < end )\n"
"		{\n"
"			counter1++;\n"
"			int idx = curStart + lIdx;\n"
"			if( lIdx == 0 ) \n"
"				ldsBatchIdx[0] = curBatch;\n"
"				GROUP_LDS_BARRIER;\n"
"			ldsBatchIdx[(lIdx == 0)? lIdx:lIdx+1] = curBatch;\n"
"			GROUP_LDS_BARRIER;\n"
"//			debugInfo[gIdx].m_valInt2 = gConstraints[idx].m_batchIdx;\n"
"//			debugInfo[gIdx].m_valInt3 = idx;\n"
"\n"
"\n"
"			ldsBatchIdx[lIdx+1] = (idx<end)? gConstraints[idx].m_batchIdx : -1;\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"\n"
"			if( ldsBatchIdx[lIdx+1] == curBatch )\n"
"			{\n"
"				//	solve\n"
"\n"
"				if( solveFriction )\n"
"				{\n"
"					solveFrictionConstraint( gBodies, gShapes, &gConstraints[idx] );\n"
"					}\n"
"				else\n"
"				{\n"
"					solveContactConstraint( gBodies, gShapes, &gConstraints[idx] );\n"
"					}\n"
"			}\n"
"			else\n"
"			{\n"
"				if( ldsBatchIdx[lIdx] == curBatch )\n"
"				{\n"
"					ldsStart = idx;\n"
"					ldsNextBatch = ldsBatchIdx[lIdx+1];\n"
"				}\n"
"			}\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"			curStart += GET_GROUP_SIZE;\n"
"		}\n"
"\n"
"		if( lIdx == 0 )\n"
"		{\n"
"			ldsCurBatch = ldsNextBatch;\n"
"		}\n"
"\n"
"		GROUP_LDS_BARRIER;\n"
"	}\n"
"//	while( ldsCurBatch != -1 && iter <= 10 );\n"
"	while( ldsCurBatch != -1 && ldsCurBatch <= maxBatch );\n"
"\n"
"}\n"
"\n"
"\n"
"\n"
"//	others\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void ReorderContactKernel(__global Contact4* in, __global Contact4* out, __global int2* sortData, int4 cb )\n"
"{\n"
"	int nContacts = cb.x;\n"
"	int gIdx = GET_GLOBAL_IDX;\n"
"\n"
"	if( gIdx < nContacts )\n"
"	{\n"
"		int srcIdx = sortData[gIdx].y;\n"
"		out[gIdx] = in[srcIdx];\n"
"	}\n"
"}\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_nContacts;\n"
"	int m_staticIdx;\n"
"	float m_scale;\n"
"	int m_nSplit;\n"
"} ConstBufferSSD;\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void SetSortDataKernel(__global Contact4* gContact, __global Body* gBodies, __global int2* gSortDataOut, ConstBufferSSD cb )\n"
"{\n"
"	int gIdx = GET_GLOBAL_IDX;\n"
"	int nContacts = cb.m_nContacts;\n"
"	int staticIdx = cb.m_staticIdx;\n"
"	float scale = cb.m_scale;\n"
"	int N_SPLIT = cb.m_nSplit;\n"
"\n"
"	if( gIdx < nContacts )\n"
"	{\n"
"		int aIdx = gContact[gIdx].m_bodyAPtr;\n"
"		int bIdx = gContact[gIdx].m_bodyBPtr;\n"
"\n"
"		int idx = (aIdx == staticIdx)? bIdx: aIdx;\n"
"		float4 p = gBodies[idx].m_pos;\n"
"		int xIdx = (int)((p.x-((p.x<0.f)?1.f:0.f))*scale) & (N_SPLIT-1);\n"
"		int zIdx = (int)((p.z-((p.z<0.f)?1.f:0.f))*scale) & (N_SPLIT-1);\n"
"\n"
"		gSortDataOut[gIdx].x = (xIdx+zIdx*N_SPLIT);\n"
"		gSortDataOut[gIdx].y = gIdx;\n"
"	}\n"
"	else\n"
"	{\n"
"		gSortDataOut[gIdx].x = 0xffffffff;\n"
"	}\n"
"}\n"
"\n"
"\n"
"void setConstraint4( const float4 posA, const float4 linVelA, const float4 angVelA, float invMassA, const Matrix3x3 invInertiaA, \n"
"	const float4 posB, const float4 linVelB, const float4 angVelB, float invMassB, const Matrix3x3 invInertiaB, \n"
"	Contact4 src, float dt, float positionDrift, float positionConstraintCoeff,\n"
"	Constraint4* dstC )\n"
"{\n"
"	dstC->m_bodyA = src.m_bodyAPtr;\n"
"	dstC->m_bodyB = src.m_bodyBPtr;\n"
"\n"
"	float dtInv = 1.f/dt;\n"
"	for(int ic=0; ic<4; ic++)\n"
"	{\n"
"		dstC->m_appliedRambdaDt[ic] = 0.f;\n"
"	}\n"
"	dstC->m_fJacCoeffInv[0] = dstC->m_fJacCoeffInv[1] = 0.f;\n"
"\n"
"\n"
"	dstC->m_linear = -src.m_worldNormal;\n"
"	dstC->m_linear.w = 0.7f ;//src.getFrictionCoeff() );\n"
"	for(int ic=0; ic<4; ic++)\n"
"	{\n"
"		float4 r0 = src.m_worldPos[ic] - posA;\n"
"		float4 r1 = src.m_worldPos[ic] - posB;\n"
"\n"
"		if( ic >= src.m_worldNormal.w )//npoints\n"
"		{\n"
"			dstC->m_jacCoeffInv[ic] = 0.f;\n"
"			continue;\n"
"		}\n"
"\n"
"		float relVelN;\n"
"		{\n"
"			float4 linear, angular0, angular1;\n"
"			setLinearAndAngular(src.m_worldNormal, r0, r1, &linear, &angular0, &angular1);\n"
"\n"
"			dstC->m_jacCoeffInv[ic] = calcJacCoeff(linear, -linear, angular0, angular1,\n"
"				invMassA, &invInertiaA, invMassB, &invInertiaB );\n"
"\n"
"			relVelN = calcRelVel(linear, -linear, angular0, angular1,\n"
"				linVelA, angVelA, linVelB, angVelB);\n"
"\n"
"			float e = 0.f;//src.getRestituitionCoeff();\n"
"			if( relVelN*relVelN < 0.004f ) e = 0.f;\n"
"\n"
"			dstC->m_b[ic] = e*relVelN;\n"
"			//float penetration = src.m_worldPos[ic].w;\n"
"			dstC->m_b[ic] += (src.m_worldPos[ic].w + positionDrift)*positionConstraintCoeff*dtInv;\n"
"			dstC->m_appliedRambdaDt[ic] = 0.f;\n"
"		}\n"
"	}\n"
"\n"
"	if( src.m_worldNormal.w > 1 )//npoints\n"
"	{	//	prepare friction\n"
"		float4 center = make_float4(0.f);\n"
"		for(int i=0; i<src.m_worldNormal.w; i++) center += src.m_worldPos[i];\n"
"		center /= (float)src.m_worldNormal.w;\n"
"\n"
"		float4 tangent[2];\n"
"		tangent[0] = cross3( src.m_worldNormal, src.m_worldPos[0]-center );\n"
"		tangent[1] = cross3( tangent[0], src.m_worldNormal );\n"
"		tangent[0] = normalize3( tangent[0] );\n"
"		tangent[1] = normalize3( tangent[1] );\n"
"		float4 r[2];\n"
"		r[0] = center - posA;\n"
"		r[1] = center - posB;\n"
"\n"
"		for(int i=0; i<2; i++)\n"
"		{\n"
"			float4 linear, angular0, angular1;\n"
"			setLinearAndAngular(tangent[i], r[0], r[1], &linear, &angular0, &angular1);\n"
"\n"
"			dstC->m_fJacCoeffInv[i] = calcJacCoeff(linear, -linear, angular0, angular1,\n"
"				invMassA, &invInertiaA, invMassB, &invInertiaB );\n"
"			dstC->m_fAppliedRambdaDt[i] = 0.f;\n"
"		}\n"
"		dstC->m_center = center;\n"
"	}\n"
"	else\n"
"	{\n"
"		//	single point constraint\n"
"	}\n"
"\n"
"	for(int i=0; i<4; i++)\n"
"	{\n"
"		if( i<src.m_worldNormal.w )\n"
"		{\n"
"			dstC->m_worldPos[i] = src.m_worldPos[i];\n"
"		}\n"
"		else\n"
"		{\n"
"			dstC->m_worldPos[i] = make_float4(0.f);\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_nContacts;\n"
"	float m_dt;\n"
"	float m_positionDrift;\n"
"	float m_positionConstraintCoeff;\n"
"} ConstBufferCTC;\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void ContactToConstraintKernel(__global Contact4* gContact, __global Body* gBodies, __global Shape* gShapes, __global Constraint4* gConstraintOut, ConstBufferCTC cb)\n"
"{\n"
"	int gIdx = GET_GLOBAL_IDX;\n"
"	int nContacts = cb.m_nContacts;\n"
"	float dt = cb.m_dt;\n"
"	float positionDrift = cb.m_positionDrift;\n"
"	float positionConstraintCoeff = cb.m_positionConstraintCoeff;\n"
"\n"
"	if( gIdx < nContacts )\n"
"	{\n"
"		int aIdx = gContact[gIdx].m_bodyAPtr;\n"
"		int bIdx = gContact[gIdx].m_bodyBPtr;\n"
"\n"
"		float4 posA = gBodies[aIdx].m_pos;\n"
"		float4 linVelA = gBodies[aIdx].m_linVel;\n"
"		float4 angVelA = gBodies[aIdx].m_angVel;\n"
"		float invMassA = gBodies[aIdx].m_invMass;\n"
"		Matrix3x3 invInertiaA = gShapes[aIdx].m_invInertia;\n"
"\n"
"		float4 posB = gBodies[bIdx].m_pos;\n"
"		float4 linVelB = gBodies[bIdx].m_linVel;\n"
"		float4 angVelB = gBodies[bIdx].m_angVel;\n"
"		float invMassB = gBodies[bIdx].m_invMass;\n"
"		Matrix3x3 invInertiaB = gShapes[bIdx].m_invInertia;\n"
"\n"
"		Constraint4 cs;\n"
"\n"
"		setConstraint4( posA, linVelA, angVelA, invMassA, invInertiaA, posB, linVelB, angVelB, invMassB, invInertiaB,\n"
"			gContact[gIdx], dt, positionDrift, positionConstraintCoeff, \n"
"			&cs );\n"
"		\n"
"		cs.m_batchIdx = gContact[gIdx].m_batchIdx;\n"
"\n"
"		gConstraintOut[gIdx] = cs;\n"
"	}\n"
"}\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void CopyConstraintKernel(__global Contact4* gIn, __global Contact4* gOut, int4 cb )\n"
"{\n"
"	int gIdx = GET_GLOBAL_IDX;\n"
"	if( gIdx < cb.x )\n"
"	{\n"
"		gOut[gIdx] = gIn[gIdx];\n"
"	}\n"
"}\n"
;
